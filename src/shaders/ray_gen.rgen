#version 460
#extension GL_GOOGLE_include_directive: require
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int16 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int32 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

#include "rand.glsl"
#include "common.glsl"
#include "material.glsl"

#define MATERIAL_INDEX_MASK 0xFFFFFF
#define UINT32_INDICES_MASK 0x80000000
struct Primitive {
    uint64_t index_address;
    uint64_t normal_address;
    uint64_t tangent_address;
    uint64_t uv_address;
    uint info;
};

struct TriangleData {
    vec2 uv;
    vec3 normal;
    vec3 tangent;
    uint material_index;
};

layout(constant_id = 0) const uint NUM_SAMPLES = 1;
layout(constant_id = 1) const uint NUM_BOUNCES = 2;

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba32f) uniform image2D image;
layout(binding = 2, set = 0) readonly buffer Primitives {
    Primitive i[];
} primitives;

layout(push_constant) uniform PushConstants {
    vec4 position;
    vec4 horizontal;
    vec4 vertical;
    vec4 forward;
    uint frame_count;
} pcs;

layout(buffer_reference, scalar) readonly buffer Normals {
    vec3 v[];
};
layout(buffer_reference, scalar) readonly buffer Tangents {
    vec4 v[];
};
layout(buffer_reference, scalar) readonly buffer Uvs {
    vec2 v[];
};
layout(buffer_reference, scalar) readonly buffer Indices16 {
    uint16_t i[];
};
layout(buffer_reference, scalar) readonly buffer Indices32 {
    uint i[];
};

layout(location = 0) rayPayloadEXT Payload payload;

TriangleData getTriangleData(uint primitive_index, uint triangle_index, vec2 barycentric) {
    TriangleData triangle_data;
    const vec3 coords = vec3(
            1.0f - payload.barycentric.x - payload.barycentric.y,
            payload.barycentric.x,
            payload.barycentric.y
        );
    const Primitive primitive = primitives.i[primitive_index];

    uvec3 index;
    if ((primitive.info & UINT32_INDICES_MASK) == 0) {
        Indices16 indices = Indices16(primitive.index_address);
        const uint16_t index0 = indices.i[3 * triangle_index + 0];
        const uint16_t index1 = indices.i[3 * triangle_index + 1];
        const uint16_t index2 = indices.i[3 * triangle_index + 2];
        index = uvec3(index0, index1, index2);
    } else {
        Indices32 indices = Indices32(primitive.index_address);
        const uint index0 = indices.i[3 * triangle_index + 0];
        const uint index1 = indices.i[3 * triangle_index + 1];
        const uint index2 = indices.i[3 * triangle_index + 2];
        index = uvec3(index0, index1, index2);
    }

    Uvs uvs = Uvs(primitive.uv_address);
    const vec2 uv0 = uvs.v[index.x];
    const vec2 uv1 = uvs.v[index.y];
    const vec2 uv2 = uvs.v[index.z];
    triangle_data.uv = vec2(uv0 * coords.x + uv1 * coords.y + uv2 * coords.z);

    Normals normals = Normals(primitive.normal_address);
    const vec3 n0 = normals.v[index.x].xyz;
    const vec3 n1 = normals.v[index.y].xyz;
    const vec3 n2 = normals.v[index.z].xyz;
    triangle_data.normal = normalize(n0 * coords.x + n1 * coords.y + n2 * coords.z);

    Tangents tangents = Tangents(primitive.tangent_address);
    const vec4 t0 = tangents.v[index.x];
    const vec4 t1 = tangents.v[index.y];
    const vec4 t2 = tangents.v[index.z];
    const vec4 surface_tangent_4 = normalize(t0 * coords.x + t1 * coords.y + t2 * coords.z);
    triangle_data.tangent = surface_tangent_4.xyz * surface_tangent_4.w;

    triangle_data.material_index = primitive.info & MATERIAL_INDEX_MASK;

    return triangle_data;
}

mat3 normalMatrix(vec3 normal) {
    vec3 orthogonal;
    if (abs(normal.x) > 0.99) {
        orthogonal = vec3(0, 0, 1);
    } else {
        orthogonal = vec3(1, 0, 0);
    }

    const vec3 tangent = normalize(cross(normal, orthogonal));
    const vec3 bitangent = normalize(cross(normal, tangent));
    return mat3(tangent, bitangent, normal);
}

void main() {
    const vec2 pixel = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    const vec2 uv = pixel / vec2(gl_LaunchSizeEXT.xy);
    const vec2 d = uv * 2.0f - 1.0f;

    const float tmin = 0.001f;
    const float tmax = 10000.0f;

    uint rng_state = tea(gl_LaunchIDEXT.x * pcs.frame_count, gl_LaunchIDEXT.y * pcs.frame_count);

    vec3 final_color = vec3(0.0);
    for (int i = 0; i < NUM_SAMPLES; ++i) {
        vec3 color = vec3(0.0);
        vec3 atten = vec3(1.0);
        vec3 origin = pcs.position.xyz;
        vec3 direction = normalize(pcs.forward.xyz + pcs.horizontal.xyz * d.x - pcs.vertical.xyz * d.y);
        for (int j = 0; j < NUM_BOUNCES; ++j) {
            payload.t = 1e32;
            traceRayEXT(
                topLevelAS,
                gl_RayFlagsOpaqueEXT | gl_RayFlagsCullBackFacingTrianglesEXT,
                0xff,
                0,
                0,
                0,
                origin.xyz,
                tmin,
                direction.xyz,
                tmax,
                0
            );

            if (payload.t == 1e32) {
                float t = 0.5 * (direction.y + 1.0);
                vec3 white = vec3(1.0, 1.0, 1.0);
                vec3 blue = vec3(0.5, 0.7, 1.0);
                color += atten * mix(white, blue, t);
                break;
            } else {
                const TriangleData triangle_data = getTriangleData(
                        payload.primitive_index,
                        payload.triangle_index,
                        payload.barycentric
                    );

                const MaterialData material_data = getMaterialData(
                        triangle_data.material_index,
                        triangle_data.uv
                    );

                color += material_data.emissive * 10.0 * atten;
                atten *= material_data.albedo * 0.5;

                if (j < NUM_BOUNCES - 1) {
                    const vec3 bitangent = normalize(cross(triangle_data.normal, triangle_data.tangent));

                    const mat3 TBN = mat3(
                            triangle_data.tangent,
                            bitangent,
                            triangle_data.normal
                        ) * mat3(payload.object_to_world);
                    vec3 normal = normalize(TBN * normalize(2.0 * material_data.normal - vec3(1.0)));

                    origin += direction * payload.t + (triangle_data.normal * mat3(payload.object_to_world)) * 0.01f;

                    const vec3 diffuse = cosine_weighted_sample(rng_state, normalMatrix(normal));
                    const vec3 reflection = reflect(direction, normal);
                    direction = normalize(mix(reflection, diffuse, material_data.roughness));
                }
            }
        }
        final_color += color;
    }

    final_color /= NUM_SAMPLES;

    final_color = vec3(
            sqrt(final_color.r),
            sqrt(final_color.g),
            sqrt(final_color.b)
        );
    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(final_color, 1.0f));
}
